// Code generated by mcp-codegen. DO NOT EDIT.
package godoc

import (
	"context"
	"encoding/json"
	"fmt"
	"slices"

	mcp "github.com/ktr0731/go-mcp"
	"github.com/ktr0731/go-mcp/protocol"
)

// ServerPromptHandler is the interface for prompt handlers.
type ServerPromptHandler interface {
}

// ServerToolHandler is the interface for tool handlers.
type ServerToolHandler interface {
	HandleToolListPackages(ctx context.Context, req *ToolListPackagesRequest) (*mcp.CallToolResult, error)
	HandleToolInspectPackage(ctx context.Context, req *ToolInspectPackageRequest) (*mcp.CallToolResult, error)
	HandleToolGetDocStruct(ctx context.Context, req *ToolGetDocStructRequest) (*mcp.CallToolResult, error)
	HandleToolGetDocFunc(ctx context.Context, req *ToolGetDocFuncRequest) (*mcp.CallToolResult, error)
	HandleToolGetDocMethod(ctx context.Context, req *ToolGetDocMethodRequest) (*mcp.CallToolResult, error)
	HandleToolGetDocConstAndVar(ctx context.Context, req *ToolGetDocConstAndVarRequest) (*mcp.CallToolResult, error)
}

// ToolListPackagesRequest contains input parameters for the list_packages tool.
type ToolListPackagesRequest struct {
}

// ToolInspectPackageRequest contains input parameters for the inspect_package tool.
type ToolInspectPackageRequest struct {
	PackageName     string `json:"package_name"`
	IncludeComments bool   `json:"include_comments,omitempty"`
}

// ToolGetDocStructRequest contains input parameters for the get_doc_struct tool.
type ToolGetDocStructRequest struct {
	PackageName string `json:"package_name"`
	StructName  string `json:"struct_name"`
}

// ToolGetDocFuncRequest contains input parameters for the get_doc_func tool.
type ToolGetDocFuncRequest struct {
	PackageName string `json:"package_name"`
	FuncName    string `json:"func_name"`
}

// ToolGetDocMethodRequest contains input parameters for the get_doc_method tool.
type ToolGetDocMethodRequest struct {
	PackageName string `json:"package_name"`
	StructName  string `json:"struct_name"`
	MethodName  string `json:"method_name"`
}

// ToolGetDocConstAndVarRequest contains input parameters for the get_doc_const_and_var tool.
type ToolGetDocConstAndVarRequest struct {
	PackageName string `json:"package_name"`
}

// PromptList contains all available prompts.
var PromptList = []protocol.Prompt{}

// JSON Schema type definitions generated from inputSchema
var (
	ToolListPackagesInputSchema      = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{},"additionalProperties":false,"type":"object"}`)
	ToolInspectPackageInputSchema    = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{"package_name":{"type":"string","description":"Package name"},"include_comments":{"type":"boolean","description":"Whether to include comments","default":true}},"additionalProperties":false,"type":"object","required":["package_name"]}`)
	ToolGetDocStructInputSchema      = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{"package_name":{"type":"string","description":"Package name of the struct"},"struct_name":{"type":"string","description":"Name of the struct"}},"additionalProperties":false,"type":"object","required":["package_name","struct_name"]}`)
	ToolGetDocFuncInputSchema        = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{"package_name":{"type":"string","description":"Package name of the function"},"func_name":{"type":"string","description":"Name of the function"}},"additionalProperties":false,"type":"object","required":["package_name","func_name"]}`)
	ToolGetDocMethodInputSchema      = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{"package_name":{"type":"string","description":"Package name of the struct"},"struct_name":{"type":"string","description":"Name of the struct"},"method_name":{"type":"string","description":"Name of the method"}},"additionalProperties":false,"type":"object","required":["package_name","struct_name","method_name"]}`)
	ToolGetDocConstAndVarInputSchema = json.RawMessage(`{"$schema":"https://json-schema.org/draft/2020-12/schema","properties":{"package_name":{"type":"string","description":"Package name"}},"additionalProperties":false,"type":"object","required":["package_name"]}`)
)

// ToolList contains all available tools.
var ToolList = []protocol.Tool{
	{
		Name:        "list_packages",
		Description: "Display a list of loaded packages and their package comments",
		InputSchema: ToolListPackagesInputSchema,
	},
	{
		Name:        "inspect_package",
		Description: "List publicly available structs, methods, and functions in the specified package",
		InputSchema: ToolInspectPackageInputSchema,
	},
	{
		Name:        "get_doc_struct",
		Description: "Return information about the specified struct",
		InputSchema: ToolGetDocStructInputSchema,
	},
	{
		Name:        "get_doc_func",
		Description: "Return information about the specified function",
		InputSchema: ToolGetDocFuncInputSchema,
	},
	{
		Name:        "get_doc_method",
		Description: "Return information about the specified method of a struct",
		InputSchema: ToolGetDocMethodInputSchema,
	},
	{
		Name:        "get_doc_const_and_var",
		Description: "Return information about constants and variables in the specified package",
		InputSchema: ToolGetDocConstAndVarInputSchema,
	},
}

// NewHandler creates a new MCP handler.
func NewHandler(toolHandler ServerToolHandler) *mcp.Handler {
	h := &mcp.Handler{}
	h.Capabilities = protocol.ServerCapabilities{
		Tools:   &protocol.ToolCapability{},
		Logging: &protocol.LoggingCapability{},
	}
	h.Implementation = protocol.Implementation{
		Name:    "GoDoc MCP Server",
		Version: "0.0.1",
	}
	h.Tools = ToolList
	h.ToolHandler = protocol.ServerHandlerFunc[protocol.CallToolRequestParams](func(ctx context.Context, method string, req protocol.CallToolRequestParams) (any, error) {
		idx := slices.IndexFunc(ToolList, func(t protocol.Tool) bool {
			return t.Name == req.Name
		})
		if idx == -1 {
			return nil, fmt.Errorf("tool not found: %s", req.Name)
		}
		switch method {
		case "tools/call":
			switch req.Name {
			case "list_packages":
				var in ToolListPackagesRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolListPackages(ctx, &in)
			case "inspect_package":
				var in ToolInspectPackageRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolInspectPackage(ctx, &in)
			case "get_doc_struct":
				var in ToolGetDocStructRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolGetDocStruct(ctx, &in)
			case "get_doc_func":
				var in ToolGetDocFuncRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolGetDocFunc(ctx, &in)
			case "get_doc_method":
				var in ToolGetDocMethodRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolGetDocMethod(ctx, &in)
			case "get_doc_const_and_var":
				var in ToolGetDocConstAndVarRequest
				if err := json.Unmarshal(req.Arguments, &in); err != nil {
					return nil, err
				}
				inputSchema, _ := ToolList[idx].InputSchema.(json.RawMessage)
				if err := protocol.ValidateByJSONSchema(string(inputSchema), in); err != nil {
					return nil, err
				}
				return toolHandler.HandleToolGetDocConstAndVar(ctx, &in)
			default:
				return nil, fmt.Errorf("tool not found: %s", req.Name)
			}
		default:
			return nil, fmt.Errorf("method %s not found", method)
		}
	})
	return h
}
